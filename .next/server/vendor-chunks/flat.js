/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/flat";
exports.ids = ["vendor-chunks/flat"];
exports.modules = {

/***/ "(rsc)/./node_modules/flat/index.js":
/*!************************************!*\
  !*** ./node_modules/flat/index.js ***!
  \************************************/
/***/ ((module) => {

eval("module.exports = flatten\nflatten.flatten = flatten\nflatten.unflatten = unflatten\n\nfunction isBuffer (obj) {\n  return obj &&\n    obj.constructor &&\n    (typeof obj.constructor.isBuffer === 'function') &&\n    obj.constructor.isBuffer(obj)\n}\n\nfunction keyIdentity (key) {\n  return key\n}\n\nfunction flatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const maxDepth = opts.maxDepth\n  const transformKey = opts.transformKey || keyIdentity\n  const output = {}\n\n  function step (object, prev, currentDepth) {\n    currentDepth = currentDepth || 1\n    Object.keys(object).forEach(function (key) {\n      const value = object[key]\n      const isarray = opts.safe && Array.isArray(value)\n      const type = Object.prototype.toString.call(value)\n      const isbuffer = isBuffer(value)\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      const newKey = prev\n        ? prev + delimiter + transformKey(key)\n        : transformKey(key)\n\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length &&\n        (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1)\n      }\n\n      output[newKey] = value\n    })\n  }\n\n  step(target)\n\n  return output\n}\n\nfunction unflatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const overwrite = opts.overwrite || false\n  const transformKey = opts.transformKey || keyIdentity\n  const result = {}\n\n  const isbuffer = isBuffer(target)\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target\n  }\n\n  // safely ensure that the key is\n  // an integer.\n  function getkey (key) {\n    const parsedKey = Number(key)\n\n    return (\n      isNaN(parsedKey) ||\n      key.indexOf('.') !== -1 ||\n      opts.object\n    ) ? key\n      : parsedKey\n  }\n\n  function addKeys (keyPrefix, recipient, target) {\n    return Object.keys(target).reduce(function (result, key) {\n      result[keyPrefix + delimiter + key] = target[key]\n\n      return result\n    }, recipient)\n  }\n\n  function isEmpty (val) {\n    const type = Object.prototype.toString.call(val)\n    const isArray = type === '[object Array]'\n    const isObject = type === '[object Object]'\n\n    if (!val) {\n      return true\n    } else if (isArray) {\n      return !val.length\n    } else if (isObject) {\n      return !Object.keys(val).length\n    }\n  }\n\n  target = Object.keys(target).reduce(function (result, key) {\n    const type = Object.prototype.toString.call(target[key])\n    const isObject = (type === '[object Object]' || type === '[object Array]')\n    if (!isObject || isEmpty(target[key])) {\n      result[key] = target[key]\n      return result\n    } else {\n      return addKeys(\n        key,\n        result,\n        flatten(target[key], opts)\n      )\n    }\n  }, {})\n\n  Object.keys(target).forEach(function (key) {\n    const split = key.split(delimiter).map(transformKey)\n    let key1 = getkey(split.shift())\n    let key2 = getkey(split[0])\n    let recipient = result\n\n    while (key2 !== undefined) {\n      if (key1 === '__proto__') {\n        return\n      }\n\n      const type = Object.prototype.toString.call(recipient[key1])\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      // do not write over falsey, non-undefined values if overwrite is false\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return\n      }\n\n      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {\n        recipient[key1] = (\n          typeof key2 === 'number' &&\n          !opts.object ? [] : {}\n        )\n      }\n\n      recipient = recipient[key1]\n      if (split.length > 0) {\n        key1 = getkey(split.shift())\n        key2 = getkey(split[0])\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = unflatten(target[key], opts)\n  })\n\n  return result\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmxhdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1yZXNlYXJjaC1uZXR3b3JrLy4vbm9kZV9tb2R1bGVzL2ZsYXQvaW5kZXguanM/NTE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5cbmZsYXR0ZW4uZmxhdHRlbiA9IGZsYXR0ZW5cbmZsYXR0ZW4udW5mbGF0dGVuID0gdW5mbGF0dGVuXG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJlxuICAgIG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICh0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSAmJlxuICAgIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbmZ1bmN0aW9uIGtleUlkZW50aXR5IChrZXkpIHtcbiAgcmV0dXJuIGtleVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuICh0YXJnZXQsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBjb25zdCBkZWxpbWl0ZXIgPSBvcHRzLmRlbGltaXRlciB8fCAnLidcbiAgY29uc3QgbWF4RGVwdGggPSBvcHRzLm1heERlcHRoXG4gIGNvbnN0IHRyYW5zZm9ybUtleSA9IG9wdHMudHJhbnNmb3JtS2V5IHx8IGtleUlkZW50aXR5XG4gIGNvbnN0IG91dHB1dCA9IHt9XG5cbiAgZnVuY3Rpb24gc3RlcCAob2JqZWN0LCBwcmV2LCBjdXJyZW50RGVwdGgpIHtcbiAgICBjdXJyZW50RGVwdGggPSBjdXJyZW50RGVwdGggfHwgMVxuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldXG4gICAgICBjb25zdCBpc2FycmF5ID0gb3B0cy5zYWZlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxuICAgICAgY29uc3QgaXNidWZmZXIgPSBpc0J1ZmZlcih2YWx1ZSlcbiAgICAgIGNvbnN0IGlzb2JqZWN0ID0gKFxuICAgICAgICB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fFxuICAgICAgICB0eXBlID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICApXG5cbiAgICAgIGNvbnN0IG5ld0tleSA9IHByZXZcbiAgICAgICAgPyBwcmV2ICsgZGVsaW1pdGVyICsgdHJhbnNmb3JtS2V5KGtleSlcbiAgICAgICAgOiB0cmFuc2Zvcm1LZXkoa2V5KVxuXG4gICAgICBpZiAoIWlzYXJyYXkgJiYgIWlzYnVmZmVyICYmIGlzb2JqZWN0ICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggJiZcbiAgICAgICAgKCFvcHRzLm1heERlcHRoIHx8IGN1cnJlbnREZXB0aCA8IG1heERlcHRoKSkge1xuICAgICAgICByZXR1cm4gc3RlcCh2YWx1ZSwgbmV3S2V5LCBjdXJyZW50RGVwdGggKyAxKVxuICAgICAgfVxuXG4gICAgICBvdXRwdXRbbmV3S2V5XSA9IHZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIHN0ZXAodGFyZ2V0KVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gdW5mbGF0dGVuICh0YXJnZXQsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBjb25zdCBkZWxpbWl0ZXIgPSBvcHRzLmRlbGltaXRlciB8fCAnLidcbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgZmFsc2VcbiAgY29uc3QgdHJhbnNmb3JtS2V5ID0gb3B0cy50cmFuc2Zvcm1LZXkgfHwga2V5SWRlbnRpdHlcbiAgY29uc3QgcmVzdWx0ID0ge31cblxuICBjb25zdCBpc2J1ZmZlciA9IGlzQnVmZmVyKHRhcmdldClcbiAgaWYgKGlzYnVmZmVyIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXQpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8vIHNhZmVseSBlbnN1cmUgdGhhdCB0aGUga2V5IGlzXG4gIC8vIGFuIGludGVnZXIuXG4gIGZ1bmN0aW9uIGdldGtleSAoa2V5KSB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gTnVtYmVyKGtleSlcblxuICAgIHJldHVybiAoXG4gICAgICBpc05hTihwYXJzZWRLZXkpIHx8XG4gICAgICBrZXkuaW5kZXhPZignLicpICE9PSAtMSB8fFxuICAgICAgb3B0cy5vYmplY3RcbiAgICApID8ga2V5XG4gICAgICA6IHBhcnNlZEtleVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkS2V5cyAoa2V5UHJlZml4LCByZWNpcGllbnQsIHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXlQcmVmaXggKyBkZWxpbWl0ZXIgKyBrZXldID0gdGFyZ2V0W2tleV1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sIHJlY2lwaWVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHkgKHZhbCkge1xuICAgIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKVxuICAgIGNvbnN0IGlzQXJyYXkgPSB0eXBlID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgY29uc3QgaXNPYmplY3QgPSB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJ1xuXG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KSB7XG4gICAgICByZXR1cm4gIXZhbC5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KSB7XG4gICAgICByZXR1cm4gIU9iamVjdC5rZXlzKHZhbCkubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0ID0gT2JqZWN0LmtleXModGFyZ2V0KS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXRba2V5XSlcbiAgICBjb25zdCBpc09iamVjdCA9ICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgIGlmICghaXNPYmplY3QgfHwgaXNFbXB0eSh0YXJnZXRba2V5XSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdGFyZ2V0W2tleV1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZEtleXMoXG4gICAgICAgIGtleSxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBmbGF0dGVuKHRhcmdldFtrZXldLCBvcHRzKVxuICAgICAgKVxuICAgIH1cbiAgfSwge30pXG5cbiAgT2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjb25zdCBzcGxpdCA9IGtleS5zcGxpdChkZWxpbWl0ZXIpLm1hcCh0cmFuc2Zvcm1LZXkpXG4gICAgbGV0IGtleTEgPSBnZXRrZXkoc3BsaXQuc2hpZnQoKSlcbiAgICBsZXQga2V5MiA9IGdldGtleShzcGxpdFswXSlcbiAgICBsZXQgcmVjaXBpZW50ID0gcmVzdWx0XG5cbiAgICB3aGlsZSAoa2V5MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoa2V5MSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVjaXBpZW50W2tleTFdKVxuICAgICAgY29uc3QgaXNvYmplY3QgPSAoXG4gICAgICAgIHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8XG4gICAgICAgIHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICAgIClcblxuICAgICAgLy8gZG8gbm90IHdyaXRlIG92ZXIgZmFsc2V5LCBub24tdW5kZWZpbmVkIHZhbHVlcyBpZiBvdmVyd3JpdGUgaXMgZmFsc2VcbiAgICAgIGlmICghb3ZlcndyaXRlICYmICFpc29iamVjdCAmJiB0eXBlb2YgcmVjaXBpZW50W2tleTFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKChvdmVyd3JpdGUgJiYgIWlzb2JqZWN0KSB8fCAoIW92ZXJ3cml0ZSAmJiByZWNpcGllbnRba2V5MV0gPT0gbnVsbCkpIHtcbiAgICAgICAgcmVjaXBpZW50W2tleTFdID0gKFxuICAgICAgICAgIHR5cGVvZiBrZXkyID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFvcHRzLm9iamVjdCA/IFtdIDoge31cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZWNpcGllbnQgPSByZWNpcGllbnRba2V5MV1cbiAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGtleTEgPSBnZXRrZXkoc3BsaXQuc2hpZnQoKSlcbiAgICAgICAga2V5MiA9IGdldGtleShzcGxpdFswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1bmZsYXR0ZW4gYWdhaW4gZm9yICdtZXNzeSBvYmplY3RzJ1xuICAgIHJlY2lwaWVudFtrZXkxXSA9IHVuZmxhdHRlbih0YXJnZXRba2V5XSwgb3B0cylcbiAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/flat/index.js\n");

/***/ })

};
;